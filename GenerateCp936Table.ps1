# GenerateCp936Table.ps1
# 从 Unicode.org 下载 CP936 映射表并生成 C# 代码

param(
    [string]$OutputPath = "Cp936Table.generated.cs"
)

$ErrorActionPreference = "Stop"

$url = "https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP936.TXT"
$tempFile = [System.IO.Path]::GetTempFileName()

Write-Host "Downloading CP936 mapping table from $url..."

try {
    # 下载文件
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $url -OutFile $tempFile -UseBasicParsing
    
    Write-Host "Parsing mapping table..."
    
    # 解析映射表
    $singleByteMap = @{}  # 单字节映射 (0x00-0x7F, 0x80)
    $doubleByteMap = @{}  # 双字节映射
    
    $content = Get-Content $tempFile -Encoding UTF8
    
    foreach ($line in $content) {
        # 跳过注释和空行
        if ($line -match "^\s*#" -or $line -match "^\s*$") {
            continue
        }
        
        # 解析格式: 0xXX(XX)	0xYYYY	# comment
        if ($line -match "^0x([0-9A-Fa-f]+)\s+0x([0-9A-Fa-f]+)") {
            $cp936Hex = $matches[1]
            $unicodeHex = $matches[2]
            
            $cp936 = [Convert]::ToInt32($cp936Hex, 16)
            $unicode = [Convert]::ToInt32($unicodeHex, 16)
            
            if ($cp936 -le 0xFF) {
                # 单字节 (0x00-0x7F 是 ASCII, 0x80 是欧元符号)
                $singleByteMap[$cp936] = $unicode
            } else {
                # 双字节
                $doubleByteMap[$cp936] = $unicode
            }
        }
    }
    
    Write-Host "Found $($singleByteMap.Count) single-byte mappings and $($doubleByteMap.Count) double-byte mappings"
    
    # 生成 C# 代码
    $sb = [System.Text.StringBuilder]::new()
    
    [void]$sb.AppendLine("// <auto-generated>")
    [void]$sb.AppendLine("// This file is auto-generated by GenerateCp936Table.ps1")
    [void]$sb.AppendLine("// Source: https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP936.TXT")
    [void]$sb.AppendLine("// DO NOT EDIT MANUALLY")
    [void]$sb.AppendLine("// </auto-generated>")
    [void]$sb.AppendLine("")
    [void]$sb.AppendLine("using System.Collections.Generic;")
    [void]$sb.AppendLine("")
    [void]$sb.AppendLine("namespace BetterChineseNames")
    [void]$sb.AppendLine("{")
    [void]$sb.AppendLine("    /// <summary>")
    [void]$sb.AppendLine("    /// CP936 (GBK/GB2312) to Unicode mapping table")
    [void]$sb.AppendLine("    /// </summary>")
    [void]$sb.AppendLine("    internal static partial class Cp936Table")
    [void]$sb.AppendLine("    {")
    
    # 生成单字节映射数组 (用于快速查找 0x80 -> Euro sign)
    [void]$sb.AppendLine("        /// <summary>")
    [void]$sb.AppendLine("        /// Single-byte character mappings (0x00-0xFF)")
    [void]$sb.AppendLine("        /// Returns 0 if the byte should be treated as lead byte of double-byte sequence")
    [void]$sb.AppendLine("        /// </summary>")
    [void]$sb.AppendLine("        internal static readonly char[] SingleByte = new char[256]")
    [void]$sb.AppendLine("        {")
    
    for ($i = 0; $i -lt 256; $i += 16) {
        $lineValues = @()
        for ($j = 0; $j -lt 16; $j++) {
            $idx = $i + $j
            if ($singleByteMap.ContainsKey($idx)) {
                $lineValues += "'\u{0:X4}'" -f $singleByteMap[$idx]
            } else {
                $lineValues += "'\u0000'"
            }
        }
        $comment = "// 0x{0:X2}-0x{1:X2}" -f $i, ($i + 15)
        [void]$sb.AppendLine("            $($lineValues -join ', '), $comment")
    }
    
    [void]$sb.AppendLine("        };")
    [void]$sb.AppendLine("")
    
    # 生成双字节映射字典
    [void]$sb.AppendLine("        /// <summary>")
    [void]$sb.AppendLine("        /// Double-byte character mappings")
    [void]$sb.AppendLine("        /// Key: (leadByte << 8) | trailByte")
    [void]$sb.AppendLine("        /// Value: Unicode character")
    [void]$sb.AppendLine("        /// </summary>")
    [void]$sb.AppendLine("        internal static readonly Dictionary<ushort, char> DoubleByte = new Dictionary<ushort, char>")
    [void]$sb.AppendLine("        {")
    
    # 按 key 排序并分组输出
    $sortedKeys = $doubleByteMap.Keys | Sort-Object
    $lineBuffer = @()
    $currentPrefix = -1
    
    foreach ($key in $sortedKeys) {
        $prefix = [int]($key -shr 8)
        $unicode = $doubleByteMap[$key]
        
        if ($currentPrefix -ne $prefix) {
            if ($lineBuffer.Count -gt 0) {
                [void]$sb.AppendLine("            $($lineBuffer -join ', '),")
            }
            $lineBuffer = @()
            $currentPrefix = $prefix
            [void]$sb.AppendLine("            // Lead byte 0x{0:X2}" -f $prefix)
        }
        
        $entry = "{{ 0x{0:X4}, '\u{1:X4}' }}" -f $key, $unicode
        $lineBuffer += $entry
        
        if ($lineBuffer.Count -ge 6) {
            [void]$sb.AppendLine("            $($lineBuffer -join ', '),")
            $lineBuffer = @()
        }
    }
    
    if ($lineBuffer.Count -gt 0) {
        [void]$sb.AppendLine("            $($lineBuffer -join ', '),")
    }
    
    [void]$sb.AppendLine("        };")
    [void]$sb.AppendLine("    }")
    [void]$sb.AppendLine("}")
    
    # 写入输出文件
    $sb.ToString() | Out-File -FilePath $OutputPath -Encoding UTF8
    
    Write-Host "Generated $OutputPath successfully!"
    Write-Host "Total mappings: $($singleByteMap.Count + $doubleByteMap.Count)"
}
finally {
    # 清理临时文件
    if (Test-Path $tempFile) {
        Remove-Item $tempFile -Force
    }
}
